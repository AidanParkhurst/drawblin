// server/payments.js
// Utilities for recording Stripe payment events in Supabase.
import { getAdminSupabase } from './supabase.js';

/*
Entitlement-focused schema (no currency balance). Suggested structure:

Table: payments
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
  stripe_event_id TEXT UNIQUE
  stripe_session_id TEXT UNIQUE
  payment_intent_id TEXT UNIQUE
  status TEXT -- 'session_completed' | 'succeeded' | 'refunded' | 'failed'
  amount_total INT
  currency TEXT
  created_unix BIGINT
  customer_email TEXT
  customer_name TEXT
  account_email_supplied TEXT
  resolved_user_email TEXT
  resolved_user_id UUID REFERENCES profiles(id)
  raw_session JSONB
  raw_payment_intent JSONB
  confirmed_at TIMESTAMPTZ
  inserted_at TIMESTAMPTZ DEFAULT NOW()
  updated_at TIMESTAMPTZ DEFAULT NOW()

Table: user_entitlements
  user_id UUID PRIMARY KEY REFERENCES profiles(id) ON DELETE CASCADE
  has_premium BOOLEAN DEFAULT FALSE
  premium_since TIMESTAMPTZ
  pet_pack BOOLEAN DEFAULT FALSE
  win_bling_pack BOOLEAN DEFAULT FALSE
  more_goblins_pack BOOLEAN DEFAULT FALSE
  updated_at TIMESTAMPTZ DEFAULT NOW()

Table: entitlement_events (audit trail)
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE
  payment_id BIGINT REFERENCES payments(id) ON DELETE SET NULL
  kind TEXT  -- 'grant' | 'revoke'
  entitlement TEXT -- 'premium' | 'pet_pack' | etc
  detail JSONB
  created_at TIMESTAMPTZ DEFAULT NOW()
*/

async function resolveUserByEmail(supa, email) {
  if (!email) return { userId: null };
  try {
    // Attempt to find a profile by email if such a column exists;
    // If the schema lacks email, this will simply error and we'll ignore.
    const { data, error } = await supa.from('profiles').select('id').eq('email', email).limit(1);
    if (error) {
      // Silently ignore missing column errors
      if (!/column .* email /i.test(error.message || '')) {
        console.warn('profiles lookup error:', error.message);
      }
      return { userId: null };
    }
    if (data && data.length === 1) return { userId: data[0].id };
    return { userId: null };
  } catch (e) {
    console.warn('profiles lookup exception:', e.message);
    return { userId: null };
  }
}

function extractAccountEmail(session) {
  // Priority: explicit metadata keys, then custom_fields, then customer email
  const md = session?.metadata || {};
  const metadataEmail = md.account_email || md.drawblin_email || md.user_email || null;
  if (metadataEmail) return metadataEmail;
  // Custom fields (array of { key, text: { value } }) depends on Stripe config
  const cf = session?.custom_fields || [];
  for (const f of cf) {
    if (!f) continue;
    const key = (f.key || '').toLowerCase();
    if (['account_email','drawblin_email','user_email'].includes(key)) {
      const v = f.text?.value || null;
      if (v) return v;
    }
  }
  return null;
}

export async function recordCheckoutSessionIdentity(event) {
  const supa = getAdminSupabase();
  if (!supa) throw new Error('Supabase admin client unavailable');
  const session = event.data?.object || {};

  const sessionId = session.id;
  const paymentIntentId = session.payment_intent || null;
  const amount = session.amount_total ?? null;
  const currency = session.currency ?? null;
  const createdUnix = session.created ?? null;
  const customer = session.customer_details || {};
  const baseEmail = customer.email || null;
  const suppliedAccountEmail = extractAccountEmail(session);
  const resolvedEmail = suppliedAccountEmail || baseEmail; // preference per requirement
  const { userId } = await resolveUserByEmail(supa, resolvedEmail);

  // Use upsert; handle case where payment_intent.succeeded already inserted first.
  const insertPayload = {
    stripe_event_id: event.id,
    stripe_session_id: sessionId,
    payment_intent_id: paymentIntentId,
    status: 'session_completed',
    amount_total: amount,
    currency,
    created_unix: createdUnix,
    customer_email: baseEmail,
    customer_name: customer.name || null,
    account_email_supplied: suppliedAccountEmail || null,
    resolved_user_email: resolvedEmail || null,
    resolved_user_id: userId || null,
  raw_session: event
  };

  // If a record with this payment_intent already exists (from payment_intent.succeeded), merge minimal identity fields.
  try {
    const { error } = await supa.from('payments').upsert(insertPayload, { onConflict: 'stripe_session_id' });
    if (error) {
      // Fallback: attempt update by payment_intent_id
      if (paymentIntentId) {
        const { error: updErr } = await supa.from('payments').update({
          stripe_session_id: sessionId,
          raw_session: event,
          status: supa.rpc ? undefined : 'session_completed'
        }).eq('payment_intent_id', paymentIntentId);
        if (updErr) throw updErr;
      } else throw error;
    }
  } catch (e) {
    console.error('Failed to upsert checkout session identity:', e.message);
    throw e;
  }
  return true;
}

export async function markPaymentIntentSucceeded(event) {
  const supa = getAdminSupabase();
  if (!supa) throw new Error('Supabase admin client unavailable');
  const intent = event.data?.object || {};
  const paymentIntentId = intent.id;
  const amount = intent.amount_received ?? intent.amount ?? null;
  const currency = intent.currency ?? null;
  const createdUnix = intent.created ?? null;
  const customerEmail = intent.charges?.data?.[0]?.billing_details?.email || intent.receipt_email || null;
  const customerName = intent.charges?.data?.[0]?.billing_details?.name || null;

  // If the session already created a record we update it, otherwise create new.
  const { data: existing, error: fetchErr } = await supa.from('payments').select('id').eq('payment_intent_id', paymentIntentId).limit(1);
  if (fetchErr) {
    console.error('Fetch existing payment failed:', fetchErr.message);
  }
    if (existing && existing.length) {
    const { error: updateErr } = await supa.from('payments').update({
      amount_total: amount,
      currency,
      created_unix: createdUnix,
      customer_email: customerEmail,
      customer_name: customerName,
      raw_payment_intent: event,
      status: 'succeeded',
      confirmed_at: new Date().toISOString()
    }).eq('payment_intent_id', paymentIntentId);
    if (updateErr) {
      console.error('Failed updating payment on intent success:', updateErr.message);
      throw updateErr;
    }
  } else {
    // Insert new (session event maybe missed)
    const { error: insertErr } = await supa.from('payments').upsert({
      stripe_event_id: event.id,
      payment_intent_id: paymentIntentId,
      amount_total: amount,
      currency,
      created_unix: createdUnix,
      customer_email: customerEmail,
      customer_name: customerName,
      raw_payment_intent: event,
      status: 'succeeded',
      confirmed_at: new Date().toISOString()
    }, { onConflict: 'payment_intent_id' });
    if (insertErr) {
      console.error('Failed inserting payment on intent success:', insertErr.message);
      throw insertErr;
    }
  }
  // After ensuring payment row, attempt entitlement application if resolved_user_id present.
  try { await applyEntitlementsForPaymentIntent(paymentIntentId); } catch (e) { console.error('Entitlement application failed:', e.message); }
  return true;
}

// --- Entitlement logic ---
import { STRIPE_PRICE_PET_PACK, STRIPE_PRICE_WIN_BLING_PACK, STRIPE_PRICE_MORE_GOBLINS_PACK, STRIPE_PRICE_PREMIUM_SUB } from './env.js';

const PRICE_TO_ENTITLEMENT = Object.entries({
  premium: STRIPE_PRICE_PREMIUM_SUB,
  pet_pack: STRIPE_PRICE_PET_PACK,
  win_bling_pack: STRIPE_PRICE_WIN_BLING_PACK,
  more_goblins_pack: STRIPE_PRICE_MORE_GOBLINS_PACK
}).reduce((acc,[k,v]) => { if (v) acc[v] = k; return acc; }, {});

async function ensureUserEntitlementsRow(supa, userId) {
  const { data, error } = await supa.from('user_entitlements').select('user_id').eq('user_id', userId).limit(1);
  if (error) throw error;
  if (!data || !data.length) {
    const { error: insErr } = await supa.from('user_entitlements').insert({ user_id: userId });
    if (insErr) throw insErr;
  }
}

function extractLineItemPriceIds(intent) {
  // Need expanded intent with line_items if using Checkout Sessions; fallback to charges metadata
  const priceIds = new Set();
  // If webhook provided expanded data (rare unless you configure) - else rely on metadata mapping
  const charges = intent.charges?.data || [];
  for (const ch of charges) {
    const md = ch.metadata || {};
    for (const val of Object.values(md)) {
      if (typeof val === 'string' && val.startsWith('price_')) priceIds.add(val);
    }
  }
  // Also inspect intent metadata directly
  const md2 = intent.metadata || {};
  for (const v of Object.values(md2)) {
    if (typeof v === 'string' && v.startsWith('price_')) priceIds.add(v);
  }
  return Array.from(priceIds);
}

async function applyEntitlementsForPaymentIntent(paymentIntentId) {
  const supa = getAdminSupabase();
  if (!supa) return;
  // Fetch payment + intent payload
  const { data, error } = await supa.from('payments').select('id, resolved_user_id, raw_payment_intent, resolved_user_email').eq('payment_intent_id', paymentIntentId).maybeSingle();
  if (error || !data || !data.resolved_user_id) return; // nothing to do
  const intent = data.raw_payment_intent?.data?.object || {};
  const userId = data.resolved_user_id;

  const priceIds = extractLineItemPriceIds(intent);
  if (!priceIds.length) return;

  await ensureUserEntitlementsRow(supa, userId);

  const updates = {}; const granted = [];
  for (const pid of priceIds) {
    const ent = PRICE_TO_ENTITLEMENT[pid];
    if (!ent) continue;
    switch (ent) {
      case 'premium':
        updates.has_premium = true;
        updates.premium_since = new Date().toISOString();
        granted.push('premium');
        break;
      case 'pet_pack':
        updates.pet_pack = true; granted.push('pet_pack'); break;
      case 'win_bling_pack':
        updates.win_bling_pack = true; granted.push('win_bling_pack'); break;
      case 'more_goblins_pack':
        updates.more_goblins_pack = true; granted.push('more_goblins_pack'); break;
    }
  }
  if (Object.keys(updates).length === 0) return;
  updates.updated_at = new Date().toISOString();
  const { error: upErr } = await supa.from('user_entitlements').update(updates).eq('user_id', userId);
  if (upErr) { console.error('Failed updating entitlements:', upErr.message); return; }

  for (const g of granted) {
    await supa.from('entitlement_events').insert({
      user_id: userId,
      payment_id: data.id,
      kind: 'grant',
      entitlement: g,
      detail: { payment_intent_id: paymentIntentId }
    });
  }
}
