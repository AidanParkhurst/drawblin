// server/payments.js
// Utilities for recording Stripe payment events in Supabase.
import { getAdminSupabase } from './supabase.js';
import Stripe from 'stripe';
import { STRIPE_SECRET_KEY } from './env.js';
import { appendPaymentRecord } from './metrics.js';

/*
Entitlement-focused schema (no currency balance). Suggested structure:

Table: payments
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
  stripe_event_id TEXT UNIQUE
  stripe_session_id TEXT UNIQUE
  payment_intent_id TEXT UNIQUE
  status TEXT -- 'session_completed' | 'succeeded' | 'refunded' | 'failed'
  amount_total INT
  currency TEXT
  created_unix BIGINT
  customer_email TEXT
  customer_name TEXT
  account_email_supplied TEXT
  resolved_user_email TEXT
  resolved_user_id UUID REFERENCES profiles(id)
  raw_session JSONB
  raw_payment_intent JSONB
  confirmed_at TIMESTAMPTZ
  inserted_at TIMESTAMPTZ DEFAULT NOW()
  updated_at TIMESTAMPTZ DEFAULT NOW()

Table: user_entitlements
  user_id UUID PRIMARY KEY REFERENCES profiles(id) ON DELETE CASCADE
  has_premium BOOLEAN DEFAULT FALSE
  premium_since TIMESTAMPTZ
  pet_pack BOOLEAN DEFAULT FALSE
  win_bling_pack BOOLEAN DEFAULT FALSE
  more_goblins_pack BOOLEAN DEFAULT FALSE
  updated_at TIMESTAMPTZ DEFAULT NOW()

Table: entitlement_events (audit trail)
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE
  payment_id BIGINT REFERENCES payments(id) ON DELETE SET NULL
  kind TEXT  -- 'grant' | 'revoke'
  entitlement TEXT -- 'premium' | 'pet_pack' | etc
  detail JSONB
  created_at TIMESTAMPTZ DEFAULT NOW()
*/

async function resolveUserByEmail(supa, email) {
  if (!email) return { userId: null };
  try {
    // Attempt to find a profile by email if such a column exists;
    // If the schema lacks email, this will simply error and we'll ignore.
    const { data, error } = await supa.from('profiles').select('id').eq('email', email).limit(1);
    if (error) {
      // Silently ignore missing column errors
      if (!/column .* email /i.test(error.message || '')) {
        console.warn('profiles lookup error:', error.message);
      }
      return { userId: null };
    }
    if (data && data.length === 1) return { userId: data[0].id };
    return { userId: null };
  } catch (e) {
    console.warn('profiles lookup exception:', e.message);
    return { userId: null };
  }
}

async function fetchStripeCustomerEmail(customerId) {
  if (!STRIPE_SECRET_KEY || !customerId) return null;
  try {
    const stripe = new Stripe(STRIPE_SECRET_KEY, { apiVersion: '2024-06-20' });
    const customer = await stripe.customers.retrieve(customerId);
    if (customer && typeof customer.email === 'string' && customer.email) return customer.email;
  } catch (e) {
    console.warn('Stripe customer fetch failed:', e?.message || e);
  }
  return null;
}

function extractAccountEmail(session) {
  // Priority: explicit metadata keys, then custom_fields, then customer email
  const md = session?.metadata || {};
  const metadataEmail = md.account_email || md.drawblin_email || md.user_email || null;
  if (metadataEmail) return metadataEmail;
  // Custom fields (array of { key, text: { value } }) depends on Stripe config
  const cf = session?.custom_fields || [];
  for (const f of cf) {
    if (!f) continue;
    const key = (f.key || '').toLowerCase();
    // Accept several variants including the configured 'drawblinsaccountemail'
    if (['account_email','drawblin_email','drawblinsaccountemail','drawblins_account_email','user_email','drawblins_email'].includes(key)) {
      const v = f.text?.value || null;
      if (v) return v;
    }
  }
  return null;
}

// --- Unified order-agnostic handlers ---------------------------------------------------------
/*
Unified Payment Flow (Order-Agnostic)
------------------------------------
Stripe may deliver webhook events in any order (e.g. payment_intent.succeeded can arrive
before checkout.session.completed). Previous logic tried to react to ordering and duplicated
entitlement grant paths, causing race windows where entitlements were never granted.

This refactor makes each handler do the same core steps:
1. Extract canonical identifiers (payment_intent_id, session id) + price IDs present.
2. Upsert a single row in `payments` keyed by payment_intent_id when available else session id.
  The row accumulates raw_session, raw_payment_intent, emails, and status transitions.
3. Immediately attempt entitlement granting (tryGrantEntitlements) after every event.
  That function re-resolves the user if still unset (using any email) and gathers price IDs
  from whichever raw payloads exist (with a single optional expand fetch if needed).
4. Entitlement granting is idempotent: we fetch current state, compute only newly granted
  entitlements, update the row, then append audit events for those grants.

Result: No dependency on event ordering, minimal duplication, and aggressive user benefit.
*/

// Core idea: Each webhook event (session completed, intent succeeded) simply merges fresh data
// into a single payments row keyed by payment_intent_id (preferred) or session id fallback.
// After each merge we opportunistically attempt to grant entitlements. Entitlement granting is
// idempotent and checks existing state before inserting audit rows.

async function extractPriceIdsFromSession(session) {
  const found = new Set();
  if (!session || typeof session !== 'object') return [];
  const lineItems = (session.line_items && Array.isArray(session.line_items.data)) ? session.line_items.data : [];
  for (const li of lineItems) {
    const pid = li?.price?.id;
    if (pid && pid.startsWith('price_')) found.add(pid);
  }
  const displayItems = Array.isArray(session.display_items) ? session.display_items : [];
  for (const di of displayItems) {
    const pid = di?.price?.id || di?.plan?.id;
    if (pid && pid.startsWith('price_')) found.add(pid);
  }
  const md = session.metadata && typeof session.metadata === 'object' ? session.metadata : {};
  for (const v of Object.values(md)) if (typeof v === 'string' && v.startsWith('price_')) found.add(v);
  return Array.from(found);
}

function extractPriceIdsFromIntent(intent) {
  if (!intent) return [];
  const ids = new Set();
  const charges = intent.charges?.data || [];
  for (const ch of charges) {
    const md = ch.metadata || {};
    for (const v of Object.values(md)) if (typeof v === 'string' && v.startsWith('price_')) ids.add(v);
  }
  const md2 = intent.metadata || {};
  for (const v of Object.values(md2)) if (typeof v === 'string' && v.startsWith('price_')) ids.add(v);
  return Array.from(ids);
}

async function enrichSessionIfNeeded(sessionId) {
  if (!sessionId || !STRIPE_SECRET_KEY) return null;
  try {
    const stripe = new Stripe(STRIPE_SECRET_KEY, { apiVersion: '2024-06-20' });
    return await stripe.checkout.sessions.retrieve(sessionId, { expand: ['line_items'] });
  } catch (e) {
    console.warn('Session expand failed (non-fatal):', e.message);
    return null;
  }
}

async function upsertPaymentMerge(fields) {
  const supa = getAdminSupabase();
  if (!supa) throw new Error('Supabase admin client unavailable');
  const conflictKey = fields.payment_intent_id ? 'payment_intent_id' : 'stripe_session_id';
  const selKey = conflictKey;
  const selVal = fields[selKey];
  let existing = null;
  if (selVal) {
    try { const { data } = await supa.from('payments').select('*').eq(selKey, selVal).maybeSingle(); existing = data || null; } catch {}
  }
  // Merge logic: do not overwrite a succeeded status with session_completed.
  if (existing) {
    const statusPriority = { succeeded: 2, session_completed: 1 };
    if (existing.status && fields.status && statusPriority[existing.status] > statusPriority[fields.status]) {
      fields.status = existing.status; // keep higher status
      fields.confirmed_at = existing.confirmed_at || fields.confirmed_at || null;
    }
    // Preserve earlier raw blobs if new data lacks them
    if (!fields.raw_session && existing.raw_session) fields.raw_session = existing.raw_session;
    if (!fields.raw_payment_intent && existing.raw_payment_intent) fields.raw_payment_intent = existing.raw_payment_intent;
    // Preserve resolved user id if already set
    if (existing.resolved_user_id && !fields.resolved_user_id) fields.resolved_user_id = existing.resolved_user_id;
    if (existing.resolved_user_email && !fields.resolved_user_email) fields.resolved_user_email = existing.resolved_user_email;
  }
  const { error } = await supa.from('payments').upsert(fields, { onConflict: conflictKey });
  if (error) throw new Error(error.message);
  const { data } = await supa.from('payments').select('*').eq(selKey, selVal).maybeSingle();
  return data || null;
}

function coalesceEmail(session, intent) {
  const sessionCustomer = session?.customer_details || {};
  const intentChargeEmail = intent?.charges?.data?.[0]?.billing_details?.email || intent?.receipt_email || null;
  const suppliedAccountEmail = extractAccountEmail(session);
  return suppliedAccountEmail || sessionCustomer.email || intentChargeEmail || null;
}

async function ensureResolvedUser(supa, paymentRow) {
  if (paymentRow.resolved_user_id) return paymentRow.resolved_user_id;
  const email = paymentRow.resolved_user_email || paymentRow.account_email_supplied || paymentRow.customer_email || null;
  if (!email) return null;
  const { userId } = await resolveUserByEmail(supa, email);
  if (userId) {
    await supa.from('payments').update({ resolved_user_id: userId }).eq('id', paymentRow.id);
    return userId;
  }
  return null;
}

async function tryGrantEntitlements(paymentRow) {
  if (!paymentRow) return;
  const supa = getAdminSupabase();
  if (!supa) return;
  const userId = await ensureResolvedUser(supa, paymentRow);
  if (!userId) return;

  let priceIds = [];
  const parseRaw = (raw) => { if (!raw) return {}; if (typeof raw === 'string') { try { return JSON.parse(raw); } catch { return {}; } } return raw; };
  const rawSessionContainer = parseRaw(paymentRow.raw_session);
  const rawIntentContainer = parseRaw(paymentRow.raw_payment_intent);
  const rawSession = rawSessionContainer?.data?.object || rawSessionContainer?.object || {};
  const rawIntent = rawIntentContainer?.data?.object || rawIntentContainer?.object || {};
  const extractedSessionIds = rawSessionContainer?.extracted_price_ids || paymentRow.raw_session?.extracted_price_ids;
  if (Array.isArray(extractedSessionIds)) priceIds.push(...extractedSessionIds);
  const extractedIntentIds = rawIntentContainer?.extracted_price_ids || paymentRow.raw_payment_intent?.extracted_price_ids;
  if (Array.isArray(extractedIntentIds)) priceIds.push(...extractedIntentIds);
  priceIds.push(...extractPriceIdsFromSession(rawSession));
  priceIds.push(...extractPriceIdsFromIntent(rawIntent));
  if (!priceIds.length && paymentRow.stripe_session_id) {
    const expanded = await enrichSessionIfNeeded(paymentRow.stripe_session_id);
    priceIds.push(...extractPriceIdsFromSession(expanded));
  }
  priceIds = Array.from(new Set(priceIds.filter(p => typeof p === 'string' && p.startsWith('price_'))));
  if (!priceIds.length) return;

  await ensureUserEntitlementsRow(supa, userId);
  const { data: current } = await supa.from('user_entitlements').select('has_premium, pet_pack, win_bling_pack, more_goblins_pack').eq('user_id', userId).maybeSingle();
  const state = current || {};
  const updates = {}; const granted = [];
  for (const pid of priceIds) {
    const ent = PRICE_TO_ENTITLEMENT[pid]; if (!ent) continue;
    switch (ent) {
      case 'premium': if (!state.has_premium) { updates.has_premium = true; updates.premium_since = new Date().toISOString(); granted.push('premium'); } break;
      case 'pet_pack': if (!state.pet_pack) { updates.pet_pack = true; granted.push('pet_pack'); } break;
      case 'win_bling_pack': if (!state.win_bling_pack) { updates.win_bling_pack = true; granted.push('win_bling_pack'); } break;
      case 'more_goblins_pack': if (!state.more_goblins_pack) { updates.more_goblins_pack = true; granted.push('more_goblins_pack'); } break;
    }
  }
  if (!Object.keys(updates).length) return;
  updates.updated_at = new Date().toISOString();
  const { error: upErr } = await supa.from('user_entitlements').update(updates).eq('user_id', userId);
  if (upErr) { console.error('Entitlement update failed:', upErr.message); return; }
  for (const e of granted) {
    await supa.from('entitlement_events').insert({ user_id: userId, payment_id: paymentRow.id, kind: 'grant', entitlement: e, detail: { payment_intent_id: paymentRow.payment_intent_id || null, stripe_session_id: paymentRow.stripe_session_id || null } });
  }
  console.log('[payments] Granted entitlements', granted, 'to user', userId, 'payment', paymentRow.id);
}

export async function recordCheckoutSessionIdentity(event) {
  const supa = getAdminSupabase();
  if (!supa) throw new Error('Supabase admin client unavailable');
  const session = event.data?.object || {};
  const paymentIntentId = session.payment_intent || null;
  const sessionId = session.id || null;
  const amount = session.amount_total ?? null;
  const currency = session.currency ?? null;
  const createdUnix = session.created ?? null;
  const email = coalesceEmail(session, null);
  const customerName = session.customer_details?.name || null;

  // Extract price IDs (non-expanded) and store them on raw_session for later.
  let priceIds = await extractPriceIdsFromSession(session);
  // Attempt expand if empty (network best-effort)
  if (!priceIds.length && STRIPE_SECRET_KEY && sessionId) {
    const expanded = await enrichSessionIfNeeded(sessionId);
    if (expanded) {
      session.line_items = expanded.line_items; // copy for persistence
      priceIds = await extractPriceIdsFromSession(expanded);
    }
  }
  // Subscription fallback: if still no price ids but subscription id exists, fetch subscription items
  if (!priceIds.length && STRIPE_SECRET_KEY && session.subscription) {
    try {
      const stripe = new Stripe(STRIPE_SECRET_KEY, { apiVersion: '2024-06-20' });
      const sub = await stripe.subscriptions.retrieve(session.subscription, { expand: ['items.data.price'] });
      const items = Array.isArray(sub?.items?.data) ? sub.items.data : [];
      for (const it of items) {
        const pid = it?.price?.id;
        if (pid && pid.startsWith('price_')) priceIds.push(pid);
      }
    } catch (e) { console.warn('Subscription fetch failed (non-fatal):', e.message); }
  }
  // If still empty and mode subscription, optimistic premium grant fallback
  if (!priceIds.length && session.mode === 'subscription' && typeof STRIPE_PRICE_PREMIUM_SUB === 'string') {
    priceIds.push(STRIPE_PRICE_PREMIUM_SUB);
  }
  priceIds = Array.from(new Set(priceIds));
  const enrichedRaw = { ...event, extracted_price_ids: priceIds };

  // If the session lacks a payment_intent_id (common for subscriptions), attempt to locate an
  // existing payment row created earlier by payment_intent.succeeded that references this session
  // via payment_details.order_reference prefix.
  let mergePaymentIntentId = paymentIntentId;
  if (!mergePaymentIntentId) {
    try {
      // Query for a recent payment row whose raw_payment_intent contains order_reference==session id prefix
      const likePattern = `%"order_reference":"${sessionId?.slice(0, 24) || ''}`; // partial to be safe
      const { data: existingRows } = await supa
        .from('payments')
        .select('id,payment_intent_id,raw_payment_intent,status')
        .is('stripe_session_id', null)
        .not('payment_intent_id', 'is', null)
        .order('id', { ascending: false })
        .limit(25);
      if (existingRows) {
        for (const row of existingRows) {
          try {
            const raw = row.raw_payment_intent;
            const orderRef = raw?.data?.object?.payment_details?.order_reference || raw?.object?.payment_details?.order_reference;
            if (orderRef && sessionId && orderRef.startsWith(sessionId.slice(0, 20))) {
              mergePaymentIntentId = row.payment_intent_id;
              break;
            }
          } catch {}
        }
      }
    } catch (e) {
      console.warn('Session merge lookup failed:', e.message);
    }
  }

  const fields = {
    stripe_event_id: event.id,
    stripe_session_id: sessionId,
    payment_intent_id: mergePaymentIntentId,
    status: 'session_completed',
    amount_total: amount,
    currency,
    created_unix: createdUnix,
    customer_email: email,
    customer_name: customerName,
    account_email_supplied: extractAccountEmail(session) || null,
    resolved_user_email: email,
    raw_session: enrichedRaw,
    confirmed_at: null
  };
  let paymentRow = null;
  try {
    paymentRow = await upsertPaymentMerge(fields);
  } catch (e) {
    console.error('Session upsert failed:', e.message);
    throw e;
  }
  try { await tryGrantEntitlements(paymentRow); } catch (e) { console.warn('Entitlement grant after session failed:', e.message); }
  try { appendPaymentRecord({ kind: 'session', stripe_event_id: event.id, payment_intent_id: paymentIntentId, stripe_session_id: sessionId, amount, currency, ts: new Date().toISOString() }); } catch {}
  return true;
}

export async function markPaymentIntentSucceeded(event) {
  const supa = getAdminSupabase();
  if (!supa) throw new Error('Supabase admin client unavailable');
  const intent = event.data?.object || {};
  const paymentIntentId = intent.id;
  const amount = intent.amount_received ?? intent.amount ?? null;
  const currency = intent.currency ?? null;
  const createdUnix = intent.created ?? null;
  let email = coalesceEmail(null, intent);
  const customerName = intent.charges?.data?.[0]?.billing_details?.name || null;
  let priceIds = extractPriceIdsFromIntent(intent);
  // If subscription related and we still lack price ids, attempt session or subscription lookups.
  // First: if payment_details.order_reference looks like a session id, try retrieving session.
  const orderRef = intent?.payment_details?.order_reference || null;
  if (!priceIds.length && orderRef && STRIPE_SECRET_KEY) {
    try {
      const stripe = new Stripe(STRIPE_SECRET_KEY, { apiVersion: '2024-06-20' });
      const sess = await stripe.checkout.sessions.retrieve(orderRef, { expand: ['line_items'] });
      priceIds.push(...await extractPriceIdsFromSession(sess));
      if (!email) email = coalesceEmail(sess, null);
      // If subscription present on session, fetch subscription items
      if (sess.subscription && !priceIds.length) {
        try {
          const sub = await stripe.subscriptions.retrieve(sess.subscription, { expand: ['items.data.price'] });
          const items = Array.isArray(sub?.items?.data) ? sub.items.data : [];
          for (const it of items) { const pid = it?.price?.id; if (pid && pid.startsWith('price_')) priceIds.push(pid); }
        } catch (e2) { console.warn('Sub fetch during intent fallback failed:', e2.message); }
      }
    } catch (e) { /* swallow */ }
  }
  // Final optimistic fallback for subscription intents
  if (!priceIds.length && /subscription/i.test(intent.description || '') && typeof STRIPE_PRICE_PREMIUM_SUB === 'string') {
    priceIds.push(STRIPE_PRICE_PREMIUM_SUB);
  }
  // Customer email fetch if still missing
  if (!email && intent.customer && STRIPE_SECRET_KEY) {
    try {
      const stripe = new Stripe(STRIPE_SECRET_KEY, { apiVersion: '2024-06-20' });
      const cust = await stripe.customers.retrieve(intent.customer);
      if (cust && typeof cust.email === 'string') email = cust.email;
    } catch {}
  }
  priceIds = Array.from(new Set(priceIds));
  const enrichedRaw = { ...event, extracted_price_ids: priceIds };
  const fields = {
    stripe_event_id: event.id,
    payment_intent_id: paymentIntentId,
    status: 'succeeded',
    amount_total: amount,
    currency,
    created_unix: createdUnix,
    customer_email: email,
    customer_name: customerName,
    resolved_user_email: email,
    raw_payment_intent: enrichedRaw,
    confirmed_at: new Date().toISOString()
  };
  let paymentRow = null;
  try {
    paymentRow = await upsertPaymentMerge(fields);
  } catch (e) {
    console.error('Intent upsert failed:', e.message);
    throw e;
  }
  try { await tryGrantEntitlements(paymentRow); } catch (e) { console.warn('Entitlement grant after intent failed:', e.message); }
  try { appendPaymentRecord({ kind: 'intent_succeeded', stripe_event_id: event.id, payment_intent_id: paymentIntentId, amount, currency, ts: new Date().toISOString() }); } catch {}
  return true;
}

// --- Entitlement logic ---
import { STRIPE_PRICE_PET_PACK, STRIPE_PRICE_WIN_BLING_PACK, STRIPE_PRICE_MORE_GOBLINS_PACK, STRIPE_PRICE_PREMIUM_SUB } from './env.js';

const PRICE_TO_ENTITLEMENT = Object.entries({
  premium: STRIPE_PRICE_PREMIUM_SUB,
  pet_pack: STRIPE_PRICE_PET_PACK,
  win_bling_pack: STRIPE_PRICE_WIN_BLING_PACK,
  more_goblins_pack: STRIPE_PRICE_MORE_GOBLINS_PACK
}).reduce((acc,[k,v]) => { if (v) acc[v] = k; return acc; }, {});

async function ensureUserEntitlementsRow(supa, userId) {
  const { data, error } = await supa.from('user_entitlements').select('user_id').eq('user_id', userId).limit(1);
  if (error) throw error;
  if (!data || !data.length) {
    const { error: insErr } = await supa.from('user_entitlements').insert({ user_id: userId });
    if (insErr) throw insErr;
  }
}

function extractLineItemPriceIds(intent) {
  // Need expanded intent with line_items if using Checkout Sessions; fallback to charges metadata
  const priceIds = new Set();
  // If webhook provided expanded data (rare unless you configure) - else rely on metadata mapping
  const charges = intent.charges?.data || [];
  for (const ch of charges) {
    const md = ch.metadata || {};
    for (const val of Object.values(md)) {
      if (typeof val === 'string' && val.startsWith('price_')) priceIds.add(val);
    }
  }
  // Also inspect intent metadata directly
  const md2 = intent.metadata || {};
  for (const v of Object.values(md2)) {
    if (typeof v === 'string' && v.startsWith('price_')) priceIds.add(v);
  }
  return Array.from(priceIds);
}

// remove legacy entitlement functions (replaced by tryGrantEntitlements)

// --- Subscription cancellation / revocation ---
export async function markSubscriptionCanceledOrUpdated(event) {
  // We only act when the subscription is effectively canceled.
  const sub = event?.data?.object || {};
  const status = (sub.status || '').toLowerCase();
  const canceledAt = sub.canceled_at || null; // seconds since epoch or null
  const cancelAt = sub.cancel_at || null;
  const nowSec = Math.floor(Date.now() / 1000);
  const isCanceled = status === 'canceled' || (canceledAt && canceledAt > 0) || (cancelAt && cancelAt <= nowSec);
  if (!isCanceled) return false;

  const supa = getAdminSupabase();
  if (!supa) throw new Error('Supabase admin client unavailable');

  // Resolve user by email via Stripe customer
  const customerId = sub.customer || null;
  let email = null;
  // Some events include customer_details on latest_invoice; try that first
  try {
    email = sub?.latest_invoice?.customer_email || null;
  } catch {}
  if (!email) email = await fetchStripeCustomerEmail(customerId);
  if (!email) {
    console.warn('Subscription cancel: could not resolve customer email; skipping entitlement revoke');
    return false;
  }

  const { userId } = await resolveUserByEmail(supa, email);
  if (!userId) {
    console.warn('Subscription cancel: no matching user for email', email);
    return false;
  }

  // Ensure entitlements row exists, then revoke premium
  await ensureUserEntitlementsRow(supa, userId);
  const updates = { has_premium: false, updated_at: new Date().toISOString() };
  const { error: upErr } = await supa.from('user_entitlements').update(updates).eq('user_id', userId);
  if (upErr) {
    console.error('Failed revoking premium:', upErr.message);
    return false;
  }
  // Record audit event
  try {
    // Try to associate to a related payment record by email match (best-effort)
    let paymentId = null;
    try {
      const { data: pay } = await supa
        .from('payments')
        .select('id')
        .or(`customer_email.eq.${email},resolved_user_email.eq.${email}`)
        .order('id', { ascending: false })
        .limit(1);
      if (pay && pay.length) paymentId = pay[0].id;
    } catch {}
    await supa.from('entitlement_events').insert({
      user_id: userId,
      payment_id: paymentId,
      kind: 'revoke',
      entitlement: 'premium',
      detail: { subscription_id: sub.id, status, canceled_at: canceledAt || null, cancel_at: cancelAt || null }
    });
  } catch (e) {
    console.warn('Failed to insert entitlement revoke event:', e?.message || e);
  }
  return true;
}
