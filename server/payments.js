// server/payments.js
// Utilities for recording Stripe payment events in Supabase.
import { getAdminSupabase } from './supabase.js';
import Stripe from 'stripe';
import { STRIPE_SECRET_KEY } from './env.js';

/*
Entitlement-focused schema (no currency balance). Suggested structure:

Table: payments
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
  stripe_event_id TEXT UNIQUE
  stripe_session_id TEXT UNIQUE
  payment_intent_id TEXT UNIQUE
  status TEXT -- 'session_completed' | 'succeeded' | 'refunded' | 'failed'
  amount_total INT
  currency TEXT
  created_unix BIGINT
  customer_email TEXT
  customer_name TEXT
  account_email_supplied TEXT
  resolved_user_email TEXT
  resolved_user_id UUID REFERENCES profiles(id)
  raw_session JSONB
  raw_payment_intent JSONB
  confirmed_at TIMESTAMPTZ
  inserted_at TIMESTAMPTZ DEFAULT NOW()
  updated_at TIMESTAMPTZ DEFAULT NOW()

Table: user_entitlements
  user_id UUID PRIMARY KEY REFERENCES profiles(id) ON DELETE CASCADE
  has_premium BOOLEAN DEFAULT FALSE
  premium_since TIMESTAMPTZ
  pet_pack BOOLEAN DEFAULT FALSE
  win_bling_pack BOOLEAN DEFAULT FALSE
  more_goblins_pack BOOLEAN DEFAULT FALSE
  updated_at TIMESTAMPTZ DEFAULT NOW()

Table: entitlement_events (audit trail)
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE
  payment_id BIGINT REFERENCES payments(id) ON DELETE SET NULL
  kind TEXT  -- 'grant' | 'revoke'
  entitlement TEXT -- 'premium' | 'pet_pack' | etc
  detail JSONB
  created_at TIMESTAMPTZ DEFAULT NOW()
*/

async function resolveUserByEmail(supa, email) {
  if (!email) return { userId: null };
  try {
    // Attempt to find a profile by email if such a column exists;
    // If the schema lacks email, this will simply error and we'll ignore.
    const { data, error } = await supa.from('profiles').select('id').eq('email', email).limit(1);
    if (error) {
      // Silently ignore missing column errors
      if (!/column .* email /i.test(error.message || '')) {
        console.warn('profiles lookup error:', error.message);
      }
      return { userId: null };
    }
    if (data && data.length === 1) return { userId: data[0].id };
    return { userId: null };
  } catch (e) {
    console.warn('profiles lookup exception:', e.message);
    return { userId: null };
  }
}

async function fetchStripeCustomerEmail(customerId) {
  if (!STRIPE_SECRET_KEY || !customerId) return null;
  try {
    const stripe = new Stripe(STRIPE_SECRET_KEY, { apiVersion: '2024-06-20' });
    const customer = await stripe.customers.retrieve(customerId);
    if (customer && typeof customer.email === 'string' && customer.email) return customer.email;
  } catch (e) {
    console.warn('Stripe customer fetch failed:', e?.message || e);
  }
  return null;
}

function extractAccountEmail(session) {
  // Priority: explicit metadata keys, then custom_fields, then customer email
  const md = session?.metadata || {};
  const metadataEmail = md.account_email || md.drawblin_email || md.user_email || null;
  if (metadataEmail) return metadataEmail;
  // Custom fields (array of { key, text: { value } }) depends on Stripe config
  const cf = session?.custom_fields || [];
  for (const f of cf) {
    if (!f) continue;
    const key = (f.key || '').toLowerCase();
    if (['account_email','drawblin_email','user_email'].includes(key)) {
      const v = f.text?.value || null;
      if (v) return v;
    }
  }
  return null;
}

export async function recordCheckoutSessionIdentity(event) {
  const supa = getAdminSupabase();
  if (!supa) throw new Error('Supabase admin client unavailable');
  const session = event.data?.object || {};

  const sessionId = session.id;
  const paymentIntentId = session.payment_intent || null;
  const amount = session.amount_total ?? null;
  const currency = session.currency ?? null;
  const createdUnix = session.created ?? null;
  const customer = session.customer_details || {};
  const baseEmail = customer.email || null;
  const suppliedAccountEmail = extractAccountEmail(session);
  const resolvedEmail = suppliedAccountEmail || baseEmail; // preference per requirement
  const { userId } = await resolveUserByEmail(supa, resolvedEmail);

  console.log(`Payments: recording session ${sessionId} (intent=${paymentIntentId || 'none'}, amount=${amount || 0} ${currency || ''}, email=${resolvedEmail || baseEmail || 'n/a'}, userId=${userId || 'n/a'})`);
  // Attempt to extract price IDs for entitlement mapping.
  // The raw event usually lacks expanded line_items; if absent try retrieving expanded session from Stripe.
  let priceIdsFromSession = [];
  const collectFrom = (sess) => {
    if (!sess) return;
    // Expanded line_items
    const li = sess.line_items?.data || [];
    for (const item of li) {
      const pid = item?.price?.id;
      if (pid && pid.startsWith('price_')) priceIdsFromSession.push(pid);
    }
    // Older API shapes / display_items
    const di = sess.display_items || [];
    for (const d of di) {
      const pid = d?.price?.id || d?.plan?.id;
      if (pid && pid.startsWith('price_')) priceIdsFromSession.push(pid);
    }
    // Metadata fallbacks (sometimes integrators inject price ids manually)
    const md = sess.metadata || {};
    for (const v of Object.values(md)) {
      if (typeof v === 'string' && v.startsWith('price_')) priceIdsFromSession.push(v);
    }
  };
  collectFrom(session);
  // If still empty and we have secret & session id, attempt an expand fetch
  if (!priceIdsFromSession.length && STRIPE_SECRET_KEY && session.id) {
    try {
      const stripe = new Stripe(STRIPE_SECRET_KEY, { apiVersion: '2024-06-20' });
      const expanded = await stripe.checkout.sessions.retrieve(session.id, { expand: ['line_items'] });
      collectFrom(expanded);
    } catch (e) {
      console.warn('Expanded session fetch failed (non-fatal):', e.message);
    }
  }
  // De-dupe
  priceIdsFromSession = Array.from(new Set(priceIdsFromSession));
  // Unified insert/update payload (will be merged onto any existing payment_intent row)
  // Enrich raw event with extracted price ids for later entitlement fallback
  const enrichedEvent = { ...event, extracted_price_ids: priceIdsFromSession };

  const insertPayload = {
    stripe_event_id: event.id,
    stripe_session_id: sessionId,
    payment_intent_id: paymentIntentId,
    status: 'session_completed',
    amount_total: amount,
    currency,
    created_unix: createdUnix,
    customer_email: baseEmail,
    customer_name: customer.name || null,
    account_email_supplied: suppliedAccountEmail || null,
    resolved_user_email: resolvedEmail || null,
    resolved_user_id: userId || null,
    raw_session: enrichedEvent
  };
  try {
    if (paymentIntentId) {
      // Prefer unification on payment_intent_id to avoid race duplication
      const { error } = await supa.from('payments').upsert(insertPayload, { onConflict: 'payment_intent_id' });
      if (error) throw error;
    } else {
      // Rare: no payment_intent yet (async capture?) – fall back to session id uniqueness
      const { error } = await supa.from('payments').upsert(insertPayload, { onConflict: 'stripe_session_id' });
      if (error) throw error;
    }
  } catch (e) {
    console.error('Failed to upsert checkout session identity:', e.message);
    throw e;
  }

  // If the intent has already succeeded (possible race: intent event arrived first) try entitlement grant now
  if (paymentIntentId) {
    try { await applyEntitlementsForPaymentIntent(paymentIntentId); } catch (e) { console.warn('Post-session entitlement attempt failed:', e.message); }
  } else if (priceIdsFromSession.length && userId) {
    // Edge case: no payment intent (uncommon) but we can still seed entitlements proactively.
    try { await applyEntitlementsForSessionOnly(enrichedEvent, userId); } catch (e) { console.warn('Session-only entitlement grant failed:', e.message); }
  }
  return true;
}

export async function markPaymentIntentSucceeded(event) {
  const supa = getAdminSupabase();
  if (!supa) throw new Error('Supabase admin client unavailable');
  const intent = event.data?.object || {};
  const paymentIntentId = intent.id;
  const amount = intent.amount_received ?? intent.amount ?? null;
  const currency = intent.currency ?? null;
  const createdUnix = intent.created ?? null;
  const customerEmail = intent.charges?.data?.[0]?.billing_details?.email || intent.receipt_email || null;
  const customerName = intent.charges?.data?.[0]?.billing_details?.name || null;

  // If the session already created a record we update it, otherwise create new.
  const { data: existing, error: fetchErr } = await supa.from('payments').select('id').eq('payment_intent_id', paymentIntentId).limit(1);
  if (fetchErr) {
    console.error('Fetch existing payment failed:', fetchErr.message);
  }
    if (existing && existing.length) {
    const { error: updateErr } = await supa.from('payments').update({
      amount_total: amount,
      currency,
      created_unix: createdUnix,
      customer_email: customerEmail,
      customer_name: customerName,
      raw_payment_intent: event,
      status: 'succeeded',
      confirmed_at: new Date().toISOString()
    }).eq('payment_intent_id', paymentIntentId);
    if (updateErr) {
      console.error('Failed updating payment on intent success:', updateErr.message);
      throw updateErr;
    }
  } else {
    // Insert new (session event maybe missed)
    const { error: insertErr } = await supa.from('payments').upsert({
      stripe_event_id: event.id,
      payment_intent_id: paymentIntentId,
      amount_total: amount,
      currency,
      created_unix: createdUnix,
      customer_email: customerEmail,
      customer_name: customerName,
      raw_payment_intent: event,
      status: 'succeeded',
      confirmed_at: new Date().toISOString()
    }, { onConflict: 'payment_intent_id' });
    if (insertErr) {
      console.error('Failed inserting payment on intent success:', insertErr.message);
      throw insertErr;
    }
  }
  // After ensuring payment row, attempt entitlement application if resolved_user_id present.
  try { await applyEntitlementsForPaymentIntent(paymentIntentId); } catch (e) { console.error('Entitlement application failed:', e.message); }
  return true;
}

// --- Entitlement logic ---
import { STRIPE_PRICE_PET_PACK, STRIPE_PRICE_WIN_BLING_PACK, STRIPE_PRICE_MORE_GOBLINS_PACK, STRIPE_PRICE_PREMIUM_SUB } from './env.js';

const PRICE_TO_ENTITLEMENT = Object.entries({
  premium: STRIPE_PRICE_PREMIUM_SUB,
  pet_pack: STRIPE_PRICE_PET_PACK,
  win_bling_pack: STRIPE_PRICE_WIN_BLING_PACK,
  more_goblins_pack: STRIPE_PRICE_MORE_GOBLINS_PACK
}).reduce((acc,[k,v]) => { if (v) acc[v] = k; return acc; }, {});

async function ensureUserEntitlementsRow(supa, userId) {
  const { data, error } = await supa.from('user_entitlements').select('user_id').eq('user_id', userId).limit(1);
  if (error) throw error;
  if (!data || !data.length) {
    const { error: insErr } = await supa.from('user_entitlements').insert({ user_id: userId });
    if (insErr) throw insErr;
  }
}

function extractLineItemPriceIds(intent) {
  // Need expanded intent with line_items if using Checkout Sessions; fallback to charges metadata
  const priceIds = new Set();
  // If webhook provided expanded data (rare unless you configure) - else rely on metadata mapping
  const charges = intent.charges?.data || [];
  for (const ch of charges) {
    const md = ch.metadata || {};
    for (const val of Object.values(md)) {
      if (typeof val === 'string' && val.startsWith('price_')) priceIds.add(val);
    }
  }
  // Also inspect intent metadata directly
  const md2 = intent.metadata || {};
  for (const v of Object.values(md2)) {
    if (typeof v === 'string' && v.startsWith('price_')) priceIds.add(v);
  }
  return Array.from(priceIds);
}

async function applyEntitlementsForPaymentIntent(paymentIntentId) {
  const supa = getAdminSupabase();
  if (!supa) return;
  // Fetch payment + payloads
  const { data, error } = await supa.from('payments').select('id, resolved_user_id, raw_payment_intent, raw_session, resolved_user_email, status').eq('payment_intent_id', paymentIntentId).maybeSingle();
  if (error || !data || !data.resolved_user_id) return; // nothing to do
  const intent = data.raw_payment_intent?.data?.object || {};
  const userId = data.resolved_user_id;
  let priceIds = extractLineItemPriceIds(intent);
  if (!priceIds.length) {
    const sessionObj = data.raw_session?.data?.object || {};
    // Expanded line items (if we enriched earlier, they may now exist)
    const li = sessionObj.line_items?.data || [];
    for (const item of li) {
      const pid = item?.price?.id;
      if (pid && pid.startsWith('price_')) priceIds.push(pid);
    }
    // Enriched extraction list
    const enrichedList = data.raw_session?.extracted_price_ids || [];
    for (const pid of enrichedList) {
      if (pid && pid.startsWith('price_')) priceIds.push(pid);
    }
    // Metadata fallback
    const md = sessionObj.metadata || {};
    for (const v of Object.values(md)) {
      if (typeof v === 'string' && v.startsWith('price_')) priceIds.push(v);
    }
  }
  priceIds = Array.from(new Set(priceIds));
  if (!priceIds.length) return; // still nothing

  // Fetch current entitlements row (or create) so we can avoid duplicate events
  await ensureUserEntitlementsRow(supa, userId);
  let current = null;
  try {
    const { data: row } = await supa.from('user_entitlements').select('has_premium, pet_pack, win_bling_pack, more_goblins_pack').eq('user_id', userId).maybeSingle();
    current = row || {};
  } catch {}

  const updates = {}; const granted = [];
  for (const pid of priceIds) {
    const ent = PRICE_TO_ENTITLEMENT[pid];
    if (!ent) continue;
    switch (ent) {
      case 'premium':
        if (!current?.has_premium) {
          updates.has_premium = true;
          updates.premium_since = new Date().toISOString();
          granted.push('premium');
        }
        break;
      case 'pet_pack':
        if (!current?.pet_pack) { updates.pet_pack = true; granted.push('pet_pack'); }
        break;
      case 'win_bling_pack':
        if (!current?.win_bling_pack) { updates.win_bling_pack = true; granted.push('win_bling_pack'); }
        break;
      case 'more_goblins_pack':
        if (!current?.more_goblins_pack) { updates.more_goblins_pack = true; granted.push('more_goblins_pack'); }
        break;
    }
  }
  if (Object.keys(updates).length === 0) return;
  updates.updated_at = new Date().toISOString();
  const { error: upErr } = await supa.from('user_entitlements').update(updates).eq('user_id', userId);
  if (upErr) { console.error('Failed updating entitlements:', upErr.message); return; }

  for (const g of granted) {
    await supa.from('entitlement_events').insert({
      user_id: userId,
      payment_id: data.id,
      kind: 'grant',
      entitlement: g,
      detail: { payment_intent_id: paymentIntentId }
    });
  }
}

// Support entitlements when only a session exists (no intent yet) – rare edge case
async function applyEntitlementsForSessionOnly(enrichedEvent, userId) {
  const supa = getAdminSupabase();
  if (!supa) return;
  const priceIds = (enrichedEvent?.extracted_price_ids || []).filter(p => typeof p === 'string' && p.startsWith('price_'));
  if (!priceIds.length) return;
  await ensureUserEntitlementsRow(supa, userId);
  let current = null;
  try {
    const { data: row } = await supa.from('user_entitlements').select('has_premium, pet_pack, win_bling_pack, more_goblins_pack').eq('user_id', userId).maybeSingle();
    current = row || {};
  } catch {}
  const updates = {}; const granted = [];
  for (const pid of priceIds) {
    const ent = PRICE_TO_ENTITLEMENT[pid];
    if (!ent) continue;
    switch (ent) {
      case 'premium': if (!current?.has_premium) { updates.has_premium = true; updates.premium_since = new Date().toISOString(); granted.push('premium'); } break;
      case 'pet_pack': if (!current?.pet_pack) { updates.pet_pack = true; granted.push('pet_pack'); } break;
      case 'win_bling_pack': if (!current?.win_bling_pack) { updates.win_bling_pack = true; granted.push('win_bling_pack'); } break;
      case 'more_goblins_pack': if (!current?.more_goblins_pack) { updates.more_goblins_pack = true; granted.push('more_goblins_pack'); } break;
    }
  }
  if (!Object.keys(updates).length) return;
  updates.updated_at = new Date().toISOString();
  const { error: upErr } = await supa.from('user_entitlements').update(updates).eq('user_id', userId);
  if (upErr) { console.error('Session-only entitlement update failed:', upErr.message); return; }
  const { data: paymentRow } = await supa.from('payments').select('id').eq('stripe_session_id', enrichedEvent?.data?.object?.id || '___none___').maybeSingle();
  for (const g of granted) {
    await supa.from('entitlement_events').insert({ user_id: userId, payment_id: paymentRow?.id || null, kind: 'grant', entitlement: g, detail: { session_only: true } });
  }
}

// --- Subscription cancellation / revocation ---
export async function markSubscriptionCanceledOrUpdated(event) {
  // We only act when the subscription is effectively canceled.
  const sub = event?.data?.object || {};
  const status = (sub.status || '').toLowerCase();
  const canceledAt = sub.canceled_at || null; // seconds since epoch or null
  const cancelAt = sub.cancel_at || null;
  const nowSec = Math.floor(Date.now() / 1000);
  const isCanceled = status === 'canceled' || (canceledAt && canceledAt > 0) || (cancelAt && cancelAt <= nowSec);
  if (!isCanceled) return false;

  const supa = getAdminSupabase();
  if (!supa) throw new Error('Supabase admin client unavailable');

  // Resolve user by email via Stripe customer
  const customerId = sub.customer || null;
  let email = null;
  // Some events include customer_details on latest_invoice; try that first
  try {
    email = sub?.latest_invoice?.customer_email || null;
  } catch {}
  if (!email) email = await fetchStripeCustomerEmail(customerId);
  if (!email) {
    console.warn('Subscription cancel: could not resolve customer email; skipping entitlement revoke');
    return false;
  }

  const { userId } = await resolveUserByEmail(supa, email);
  if (!userId) {
    console.warn('Subscription cancel: no matching user for email', email);
    return false;
  }

  // Ensure entitlements row exists, then revoke premium
  await ensureUserEntitlementsRow(supa, userId);
  const updates = { has_premium: false, updated_at: new Date().toISOString() };
  const { error: upErr } = await supa.from('user_entitlements').update(updates).eq('user_id', userId);
  if (upErr) {
    console.error('Failed revoking premium:', upErr.message);
    return false;
  }
  // Record audit event
  try {
    // Try to associate to a related payment record by email match (best-effort)
    let paymentId = null;
    try {
      const { data: pay } = await supa
        .from('payments')
        .select('id')
        .or(`customer_email.eq.${email},resolved_user_email.eq.${email}`)
        .order('id', { ascending: false })
        .limit(1);
      if (pay && pay.length) paymentId = pay[0].id;
    } catch {}
    await supa.from('entitlement_events').insert({
      user_id: userId,
      payment_id: paymentId,
      kind: 'revoke',
      entitlement: 'premium',
      detail: { subscription_id: sub.id, status, canceled_at: canceledAt || null, cancel_at: cancelAt || null }
    });
  } catch (e) {
    console.warn('Failed to insert entitlement revoke event:', e?.message || e);
  }
  return true;
}
